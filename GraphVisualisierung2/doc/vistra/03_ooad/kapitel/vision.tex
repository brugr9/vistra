\chapter{Requirements}
% 
\section{Vision}
\label{sec:Vision}
% Descibes the high-level goals and constraints, the business case, and provides an executive summary.
Es soll eine Software erstellt werden, welche das Traversieren von Graphen mit verschiedenen Algorithmen darstellen kann. 

Ein beliebiger Algorithmus, wie etwa derjenige von Dijkstra soll mit diesem Werkzeug auf einfache Weise visualisiert werden. Das Werkzeug soll sich als didaktisches Hilfsmittel eignen. Neue Algorithmen sollen ohne grossen Aufwand hinzugef\"ugt werden k\"onnen. Zudem soll die Software Graphen aus einer Datei importieren k\"onnen.
% 
\subsection{Problem Statement}
\label{subsec:Problem Statement}
% 
\subsubsection{Graphen}
\label{subsubsec:Graphen}
Das System soll ungerichtete, gerichtete, ungewichtete und (positiv) gewichtete einfache Graphen mit einfachen Kanten (simple connected graphs, neither self-loops nor parallel edges) verarbeiten k\"onnen.

Ein Graph wird durch Kreise (Knoten), Geraden (ungerichtete Kanten), Pfeile (gerichtete Kanten) und Beschriftungen (Knotenbezeichnungen, Kantenbezeichnungen und Kantengewichte) dargestellt. Das System kann folgende Dateioperationen ausf\"uhren:
\begin{itemize}
  \item Es k\"onnen neue ungerichtete und gerichtete Graphen erstellt werden.
  \item Es k\"onnen als Datei vorliegende Graphen ge\"offnet werden.
  \item Graphen k\"onnen bearbeitet werden.
  \begin{itemize}
    \item Die Anordnung der Knoten kann ver\"andert werden: Diese k\"onnen mit der Maus verschoben werden.
  \end{itemize}
  \item Graphen k\"onnen gespeichert werden.
\end{itemize}
% 
\subsubsection{Algorithmen}
\label{subsubsec:Algorithmen}
Das System soll mindestens folgende implementierte Algorithmen zur Auswahl bereit halten:
\begin{itemize}
  \item Rekursive Tiefensuche (Depth-First Search, DFS)
  \item Breitensuche (Breadth-First Search, BFS)
  \item Dijkstra: Suchen des k\"urzesten Weges zwischen zwei als Start und Ende festgelegten Knoten in einem gerichteten und gewichteten Graphen (Shortest Path)
  \item Kruskal: minimaler Spannbaum berechnen (Spanning Tree)
\end{itemize}
Es sollen nur diejenigen Algorithmen ausw\"ahlbar sein, die auf den aktuellen Graph-Typ angewendet werden k\"onnen.

F\"ur manche Algorithmen soll ein Start-, z.T. auch ein Endknoten angegeben werden k\"onnen.

Ein Entwickler von Algorithmen soll auf m\"oglichst einfache Weise weitere Algorithmen implementieren und dem System hinzuf\"ugen k\"onnen.
% 
\subsubsection{Traversierung}
\label{subsubsec:Traversierung}
\begin{itemize}
  \item Die Visualisierung der Traversierung soll Schrittweise erfolgen ('Step-by-step'): Dabei soll der Benutzer vor, zur\"uck, zum Anfang oder zum Ende der Visualisierung gelangen k\"onnen.
  \item Die Schrittl\"ange soll ver\"andert werden k\"onnen.
  \item Die Visualisierung der Traversierung soll auch abgespielt werden k\"onnen (Animation). Dabei soll der Benutzer die Animation starten, pausieren oder stoppen k\"onnen.
  \item Das Tempo der Animation soll ver\"andert werden k\"onnen.
\end{itemize}
% 
\subsection{Other Requirements and Constraints}	
\label{subsec:Other Requirements and Constraints}
\begin{itemize}
  \item Zu \"offnende Graphen werden validiert.
  \item Ein Entwickler von Algorithmen muss ein gegebenes Interface implementieren und gibt an, welche Graph-Typen mit einem Algorithmus traversiert werden kann (ungerichtet, gerichtet).
  \item F\"ur ungewichtete Graphen wird ein Kanten-Gewicht der Gr\"osse 1 angenommen, es wird also nicht unterschieden zwischen ungewichtet und gewichtet.
  \item Die Visualisierung der Traversierung zeigt Schrittweise Farb\"anderungen von Knoten und Kanten, evtl. auch errechnete Zwischenergebnisse.
  \item Mit jedem Step der Visualisierung wird auf einer Protokollpanele eine Statusmeldung ausgegeben, die die begangenen Traversierungsschritte erl\"autert.
\end{itemize}